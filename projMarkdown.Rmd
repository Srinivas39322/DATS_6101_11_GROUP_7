---
title: "DATS-6101 Project"
author: "GROUP 7"
date: "2023-10-12"
output: 
  html_document:
    code_folding: hide
    number_sections: false
    toc: yes
    toc_depth: 3
    toc_float: yes
  #pdf_document:
   # toc: yes
    #toc_depth: '3'
---
Our Project uses a Apple Appstore data which has 21 columns. The variables are:

1.App_Id - Unique identifier for the app
2.App_Name - Name of the app
3.AppStore_Url - URL for the app on the Apple App Store
4.Primary_Genre - Main genre of the app
5.Content_Rating- Age rating for the app
6.Size_Bytes- Size of the app in bytes
7.Required_IOS_Version - Minimum iOS version required to run the app
8.Released - Release date of the app
9.Updated - Last update date of the app
10.Version - Current version of the app
11.Price - Price of the app
12.Currency - Currency of the app price
13.Free - Whether the app is free or not
14.DeveloperId - Unique identifier for the app's developer
15.Developer - Name of the app's developer
16.Developer_Url - URL of the developer on the Apple App Store
17.Developer_Website - Official website of the developer
18.Average_User_Rating - Average rating given by users
19.Reviews - Number of reviews
20.Current_Version_Score - Rating for the current version of the app
21.Current_Version_Reviews - Number of reviews for the current version of the app

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ezids)
library(tidyr)
library(lubridate)
library(dplyr)
library(ggplot2)
library(gridExtra)
```

### Reading the AppleStore data into dataframe
```{r read_csv}
appData = read.csv('appleAppData.csv')
```

### Dimenstions of the dataframe
```{r dataset_dimension}
dim(appData)
```

### Datatype of columns
```{r dataset_structure}
str(appData)
```

### Summary of the dataset
```{r dataset_summary}
summary(appData)
```

### First and Last few observations of the dataframe
```{r dataset_rows}
head(appData,2)
tail(appData,2)
```

### Listing the numerical and categorical variables(columns)
```{r numerical_and_categorial_cols}
numerical_cols <- sapply(appData, is.numeric)
numerical_colnames <- names(appData)[numerical_cols]

categorical_colnames <- names(appData)[!numerical_cols]

max_length <- max(length(numerical_colnames), length(categorical_colnames))

numerical_colnames <- c(numerical_colnames, rep(NA, max_length - length(numerical_colnames)))
categorical_colnames <- c(categorical_colnames, rep(NA, max_length - length(categorical_colnames)))

var_df <- data.frame(Numeric = numerical_colnames, Categorical = categorical_colnames)

print(var_df)
```

## Missing values
### Checking all missing values in the dataset
```{r check_missing_values}
na_counts <- sapply(appData, function(col) sum(is.na(col)))

blank_counts <- sapply(appData, function(col) sum(col == "" | col == " "))

result <- data.frame(Column = names(appData), NA_Count = na_counts, Blank_Count = blank_counts)
print(result)
```

### Numerical column NAs
**Barplot showing the number of missing values in columns 'Price' and 'Size_Bytes' columns**
```{r numerical_missing_values_barplot}
# Calculate missing values per column
missing_values_per_column <- colSums(is.na(appData))

# Create a data frame with column names and missing values
missing_data <- data.frame(Column = names(missing_values_per_column),
                           MissingValues = missing_values_per_column)

ggplot(missing_data, aes(x = Column, y = MissingValues)) +
  geom_bar(stat = "identity", fill = "plum3") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Column Names", y = "Number of Missing Values", 
       title = "Number of Missing Values in the dataset")

```

### Categorical column NAs
**Barplot showing the number of missing values in columns 'Developer_Url', 'Developer_Website' and 'Released' columns**
```{r categorical_missing_values_barplot}

blank_developer_url <- sum(is.na(appData$Developer_Url) | appData$Developer_Url == "")
blank_developer_website <- sum(is.na(appData$Developer_Website) | appData$Developer_Website == "")
Released <- sum(is.na(appData$Released) | appData$Released == "")

# Create a data frame for plotting
missing_data <- data.frame(
  Column = c('Developer_Url', 'Developer_Website', 'Released'),
  Missing_Values = c(blank_developer_url, blank_developer_website, Released)
)

developer_website_data <- subset(missing_data, Column == "Developer_Website")
other_data <- subset(missing_data, Column != "Developer_Website")
custom_colors <- c("Developer_Url" = "indianred4", "Developer_Website" = "indianred3", "Released"="indianred2")

# Plot for Developer_Website
plot1 <- ggplot(developer_website_data, aes(x = Column, y = Missing_Values)) +
  geom_bar(stat = "identity", aes(fill = Column), width = 0.5) +
  scale_fill_manual(values = custom_colors) +
  labs(title = "Missing Values in Developer_Website",
       x = "",
       y = "Number of Missing Values") +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma)

# Plot for Developer_Url and Released
plot2 <- ggplot(other_data, aes(x = Column, y = Missing_Values)) +
  geom_bar(stat = "identity", aes(fill = Column), width = 0.5) +
  scale_fill_manual(values = custom_colors) +
  labs(title = "Missing Values in Developer_Url \nand Released",
       x = "",
       y = "Number of Missing Values") +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma)


# Combine plots
grid.arrange(plot1, plot2, ncol = 2)

```

## Handling missing values
**Removing row with NA value in AppName column**
```{r remove_na_in_appname}
appData <- subset(appData, !is.na(App_Name))
```

**Dropping 'Developer_Website' column as it is not used in the analysis and has missing values for over half the dataset**
```{r drop_dw_col}
appData = subset(appData, select = -c(Developer_Website))
head(appData, 1)
```

**Dropping blanks in 'Released' column**
```{r drop_blanks_in_released_col}
appData <- appData %>% filter(!is.na(Released) & Released != "")
print(tail(appData,4))
```

**Updating NA values in numerical columns 'Price' and 'Size_Bytes' with their respective means**
```{r replace_numerical_na_with_means}
df_p_sb <- subset(appData, select=c("Price", "Size_Bytes"))
head(df_p_sb, 1)
meanvals <- as.list(colMeans(df_p_sb, na.rm = TRUE))
print(meanvals)
df_p_sb <- replace_na(df_p_sb, meanvals)
head(df_p_sb, 1)
appData = subset(appData, select = -c(Price))
appData = subset(appData, select = -c(Size_Bytes))
appData <- cbind(appData, Price = df_p_sb$Price)
appData <- cbind(appData, Size_Bytes = df_p_sb$Size_Bytes)
head(appData, 1)
```

**Final checking for missing values**
```{r final_check_for_missing_vals_barplot}
# Calculate missing values per column
missing_values_per_column_2 <- colSums(is.na(appData))

# Create a data frame with column names and missing values
missing_data_2 <- data.frame(Column = names(missing_values_per_column_2),
                           MissingValues = missing_values_per_column_2)

ggplot(missing_data_2, aes(x = Column, y = MissingValues)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Column Names", y = "Number of Missing Values 2", 
       title = "Number of Missing Values in the dataset")

missing_values_per_column <- colSums(is.na(appData))
print(missing_values_per_column <- colSums(is.na(appData)))
```

**Checking for duplicates**
```{r check_duplicated}
print(sum(duplicated(appData)))
```

## Datetime columns
**Converting 'Released' and 'Updated' columns datatype from object to time format**
```{r dt_cols_format}
appData$Updated <- format(ymd_hms(appData$Updated), "%m-%d-%Y %H:%M:%S")
appData$Released <- format(ymd_hms(appData$Released), "%m-%d-%Y %H:%M:%S")

appData$Released <- as.POSIXct(strptime(appData$Released, "%m-%d-%Y %H:%M:%S"))
appData$Updated <- as.POSIXct(strptime(appData$Updated, "%m-%d-%Y %H:%M:%S"))

print(head(appData,1))
```

## Apps vs Genre
```{r apps_per_genre_barplot_1}
genre_counts <- appData %>%
  group_by(Primary_Genre) %>%
  summarise(App_Count = n())

#genre_counts

ggplot(genre_counts, aes(x = Primary_Genre, y = App_Count)) +
  geom_bar(stat = 'identity', fill = 'blue', alpha = 0.5) +
  labs(title = "Number of Apps per Genre", x = "Genre", y = "Count of Apps") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Revenue vs Genre
```{r revenue_by_genre_barplot_2}
appData$Revenue <- appData$Price * appData$Reviews

revenue_by_genre <- appData %>%
group_by(Primary_Genre) %>%
summarise(Total_Revenue = sum(Revenue))

ggplot(revenue_by_genre, aes(x = reorder(Primary_Genre, -Total_Revenue), y = Total_Revenue)) +
  geom_bar(stat='identity', fill='seagreen4') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Revenue by Genre", x = "Genre", y = "Total Revenue")+
  scale_y_continuous(labels = scales::comma)
```

## Gaming apps
### Frequency over years
```{r gaming_apps_count_over_years_barplot_3}
# Extract release and update years
appData$Release_Year <- year(appData$Released)
appData$Update_Year <- year(appData$Updated)

# Count the number of games per release year
games_per_year <- appData %>% 
  group_by(Release_Year) %>%
  tally()

# Plot the bar graph
ggplot(games_per_year, aes(x = Release_Year, y = n)) +
  geom_bar(stat = 'identity', fill = 'orange4', alpha = 0.5) +
  labs(title = "Number of Games Released Per Year", x = "Release Year", y = "Number of Games") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### Reviews & Rating vs Year
```{r gaming_apps_reviews_and_ratings_over_years_barplot_4}
games_data <- appData[appData$Primary_Genre == 'Games', ]
games_data$Year <- year(as.Date(games_data$Released, format="%d-%m-%Y %H:%M:%S"))

games_by_year <- games_data %>%
  filter(!is.na(Year)) %>%
  group_by(Year) %>%
  summarise(
    Total_Reviews = sum(Reviews, na.rm = TRUE),
    Average_Rating = mean(Average_User_Rating, na.rm = TRUE)
  )

ggplot(games_by_year, aes(x = as.factor(Year))) +
  geom_col(aes(y = Total_Reviews), fill = 'pink4', alpha = 0.5) +
  geom_line(aes(y = Average_Rating*1000000, group=1), color = 'lightcyan4') +  # scaled for visualization
  geom_point(aes(y = Average_Rating*1000000), color = 'lightcyan4') +
  labs(title = "Distribution of Reviews and Rating Over Years", x = "Year", y = "Metrics") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  scale_y_continuous(labels = scales::comma)

```

## Release and Update Frequency over the years
```{r release_and_update_frequency_over_years_linechart_5}

# Calculate the number of releases and updates per year
release_counts <- table(appData$Release_Year)
update_counts <- table(appData$Update_Year)

# Create a data frame for plotting
plot_data <- data.frame(Year = as.numeric(names(release_counts)),
                        Releases = as.numeric(release_counts),
                        Updates = as.numeric(update_counts))

# Plot line chart with solid line and dots for Releases, and solid line with cross marks for Updates
ggplot(plot_data, aes(x = Year)) +
  geom_line(aes(y = Releases, color = "Releases"), linetype = "solid", size = 1) +
  geom_point(aes(y = Releases, color = "Releases"), shape = 16, size = 3) +  # Shape 16 represents dots
  geom_line(aes(y = Updates, color = "Updates"), linetype = "solid", size = 1) +
  geom_point(aes(y = Updates, color = "Updates"), shape = 4, size = 3) +  # Shape 4 represents diamond 
  labs(x = "Year", y = "Count", title = "Release and Update Frequency Over Time") +
  scale_color_manual(values = c("Releases" = "blue", "Updates" = "green")) +
  theme_minimal() + theme(legend.position="top") +
  scale_x_continuous(breaks = seq(2008, 2022, 1)) +
  scale_y_continuous(labels = scales::comma)
```


## Content Rating
#### Frequency
```{r apps_by_contentrating_barplot_6}

# Arrange data by the count of 'Content_Rating' in descending order
ordered_ratings <- appData %>% 
  group_by(Content_Rating) %>% 
  summarise(count = n()) %>%
  arrange(-count) %>%
  .$Content_Rating

# Create the bar plot
ggplot(appData, aes(x = Content_Rating)) +
  geom_bar(aes(fill = Content_Rating), show.legend = FALSE) +
  scale_x_discrete(limits = ordered_ratings) +  # Order bars
  labs(title = "Number of Apps by Content Rating", x = "Content Rating", y = "Number of Apps")
```

### Distribution
```{r apps_by_contentrating_piechart_7}
# Calculate the count of apps by Content Rating
rating_counts <- table(appData$Content_Rating)

# Create a data frame for the pie chart
rating_data <- data.frame(Content_Rating = names(rating_counts), Count = as.numeric(rating_counts))

# Define the desired order for sorting the "Name" column
desired_order <- c("4+", "9+", "12+", "17+", "Not yet rated")

# Sort the data frame based on the "Name" column using the desired order
rating_data <- rating_data %>%
  arrange(factor(Content_Rating, levels = desired_order))

# Calculate percentages
rating_data$Percentage <- (rating_data$Count / sum(rating_data$Count)) * 100
rating_data$Percentage <- round(rating_data$Percentage, 2)

rating_data

custom_colors <- c("#f8766d", "#a3a500", "#00bf7d", "#00b0f6", "slategrey")
# Create a pie chart-like plot
ggplot(rating_data, aes(x = 1, y = Percentage, fill = Content_Rating)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar(theta = "y") +
  labs(title = "Pie Chart: Content Rating", fill = "Content Rating") +
  scale_fill_manual(values = custom_colors) +
  theme_void() +
  theme(legend.position = "right")
```

### Genre vs. Content Rating
```{r genre_vs_contentrating_spbarplot_8}
pg_cr <- subset(appData, select = c('Primary_Genre', 'Content_Rating'))
pg_cr_agg <- pg_cr %>%  
             group_by(Primary_Genre, Content_Rating) %>% 
            summarise(total_count = n(), .groups = 'drop') %>% 
            pivot_wider(names_from = Content_Rating, values_from = total_count, values_fill = 0)
print(pg_cr_agg)
col_order <- c("Primary_Genre", "4+", "9+", "12+", "17+", "Not yet rated")
pg_cr_agg <- pg_cr_agg[, col_order]
pg_cr_agg


pgcr_data_long <- pg_cr_agg %>%
  gather(Rating, Count, -Primary_Genre)

# Calculate percentages within each Primary_Genre
pgcr_data_longg <- pgcr_data_long %>%
  group_by(Primary_Genre) %>%
  mutate(Percentage = (Count / sum(Count)) * 100)

# Create a stacked percentage bar chart with Primary_Genre on the x-axis
ggplot(pgcr_data_longg, aes(x = Primary_Genre, y = Percentage, fill = Rating)) +
  geom_bar(stat = "identity") +
  labs(title = "Percentage Distribution of 'Content Rating' across 'Genre'", caption = 'Stacked Percentage Bar Chart', x = "Primary Genre", y = "Content Rating %") +
  scale_fill_manual(values = c("4+" = "gold", "9+" = "darkorange", "12+" = "brown2", "17+" = "firebrick3", "Not yet rated" = "red4")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(labels = scales::percent_format(scale = 1))
```

### Pearson's Chi-squared test
**Pearson's Chi-squared test between Genre and Content_Rating**
```{r chisq_test_genre_vs_contentrating}
# Create a contingency table
contingency_table <- table(appData$Primary_Genre, appData$Content_Rating)

# Perform the chi-squared test
chi_square_result <- chisq.test(contingency_table)

# View the test result
print(chi_square_result)
```

## Analysis of Price
**Sampling 1000 rows from the dataset**
```{r}
sampled_data <- appData %>%
  sample_n(1000)
# Created custom bins for Average_User_Rating (e.g., every 0.5 units)
sampled_data$Rating_Group <- cut(sampled_data$Average_User_Rating, 
                                 breaks = seq(0, 5, by = 0.5),
                                 labels = seq(0.25, 4.75, by = 0.5))

```
### Frequency
**Frequency of 'Price' for sampled data**
```{r price_freq_barplot_9}
ggplot(sampled_data, aes(x = factor(Price))) +
  geom_bar(fill = "skyblue", color = "black") +
  labs(title = "Distribution of App Prices (Sampled Data)",
       x = "Price",
       y = "Frequency") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)
)
```

### Distribution
**Distribution of Free and Paid apps**
```{r free_vs_paid_apps_barplot_spbarplot_10_11_12}
fp <- subset(appData, select = c('Primary_Genre', 'Free'))
fp_agg <- fp %>%  
             group_by(Primary_Genre, Free) %>% 
            summarise(total_count = n(), .groups = 'drop') %>% 
            pivot_wider(names_from = Free, values_from = total_count, values_fill = 0)
# fp_agg
colnames(fp_agg) <- c("Primary_Genre", "Paid", "Free")
# fp_agg

sum_of_paid <- sum(fp_agg$Paid)
sum_of_free <- sum(fp_agg$Free)
total_apps <- sum_of_paid + sum_of_free

# Sample data
free_paid <- data.frame(
  Category = c("Paid", "Free"),
  Value = c(round((sum_of_paid/total_apps)*100, 2), round((sum_of_free/total_apps)*100,2)))

# free_paid
custom_colorss <- c("yellowgreen", "chocolate2")

# Create a pie chart
p <- ggplot(free_paid, aes(x = "", y = Value, fill = Category)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar(theta = "y") +
  labs(title = "Pie Chart for Free & Paid") +
  scale_fill_manual(values = custom_colorss) +
geom_text(aes(label = Value), position = position_stack(vjust = 0.5))
p

# Reshape the data to long format
fp_agg_long <- fp_agg %>%
  gather(Type, Count, -Primary_Genre)

ggplot(fp_agg_long, aes(x = Primary_Genre, y = Count, fill = Type)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  labs(title = "Distribution of 'Free & Paid' apps across 'Genre'", caption = 'Grouped Bar Chart', x = "Primary Genre", y = "No. of. apps") +
  scale_fill_manual(values = c("Paid" = "chocolate2", "Free" = "yellowgreen")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Calculate percentages within each Primary_Genre
fp_agg_longg <- fp_agg_long %>%
  group_by(Primary_Genre) %>%
  mutate(Percentage = (Count / sum(Count)) * 100)

# fp_agg_longg

# Create a stacked percentage bar chart with Primary_Genre on the x-axis
ggplot(fp_agg_longg, aes(x = Primary_Genre, y = Percentage, fill = Type)) +
  geom_bar(stat = "identity") +
  labs(title = "Percentage Distribution of 'Free & Paid' apps across 'Genre'", caption = 'Stacked Percentage Bar Chart', x = "Primary Genre", y = "Free & Paid apps %") +
  scale_fill_manual(values = c("Paid" = "chocolate2", "Free" = "yellowgreen")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(labels = scales::percent_format(scale = 1))
```
## Analysis of Ratings
### Frequency
** Frequency of 'Average_User_Rating' for sampled data**
```{r rating_freq_barplot_13}
### Bar plot for grouped Average_User_Rating :
ggplot(sampled_data, aes(x = Rating_Group)) +
  geom_bar(fill = "skyblue", color = "black") +
  labs(title = "Distribution of Average User Ratings (Sampled Data)",
       x = "Average User Rating",
       y = "Frequency") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

**Creating User_Rating_Type column for various ranges of the ratings**
```{r create_user_rating_type_col}
appData$User_Rating_Type <- with(appData, ifelse(Average_User_Rating > 4, 'Rating 4 to 5',
                                          ifelse(Average_User_Rating > 3, 'Rating 3 to 4',
                                          ifelse(Average_User_Rating > 2, 'Rating 2 to 3',
                                          ifelse(Average_User_Rating > 1, 'Rating 1 to 2',
                                          ifelse(Average_User_Rating > 0, 'Rating 0 to 1', 'No rating'))))))
# head(appData, 10)
```

### Distribution
**Distribution of Rating types across Genre**
```{r genre_vs_user_rating_type_spbarplot_14}
genre_user_rating_type = subset(appData, select = c("Primary_Genre", "User_Rating_Type"))
agg_table_2 <- genre_user_rating_type %>%  
             group_by(Primary_Genre, User_Rating_Type) %>% 
            summarise(total_count = n(), .groups = 'drop') %>% 
            pivot_wider(names_from = User_Rating_Type, values_from = total_count, values_fill = 0)
# print(agg_table_2)

# Reshape the data to long format
data_long <- agg_table_2 %>%
  gather(Rating, Count, -Primary_Genre)
# print(data_long)

data_longg <- data_long %>%
  group_by(Primary_Genre) %>%
  mutate(Percentage = (Count / sum(Count)) * 100)

# data_longg

# Create a stacked percentage bar chart with Primary_Genre on the x-axis
ggplot(data_longg, aes(x = Primary_Genre, y = Percentage, fill = Rating)) +
  geom_bar(stat = "identity") +
  labs(title = "Percentage Distribution of 'Rating Types' across 'Genre'", caption = 'Stacked Percentage Bar Chart', x = "Primary Genre", y = "Rating Types %") +
  scale_fill_manual(values = c("No rating" = "red", "Rating 0 to 1" = "yellow", "Rating 1 to 2" = "orange", "Rating 2 to 3" = "green",
                                "Rating 3 to 4" = "blue", "Rating 4 to 5" = "purple")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(labels = scales::percent_format(scale = 1))
```

### Most and least rated
```{r most_and_least_rated_apps_barplot_15_16}
appData$User_Rating <- with(appData, ifelse(Average_User_Rating > 0, 'Yes Rating', 'No Rating'))

genre_user_rating = subset(appData, select = c("Primary_Genre", "User_Rating"))
# genre_user_rating

agg_table <- genre_user_rating %>% 
             group_by(Primary_Genre, User_Rating) %>%
             summarise(total_count = n(), .groups = 'drop') %>%
             pivot_wider(names_from = User_Rating, values_from = total_count, values_fill = 0)
colnames(agg_table) <- c("Primary_Genre", "No_Rating", "Yes_Rating")
# print(agg_table)

agg_table$Total_Rating <- agg_table$No_Rating + agg_table$Yes_Rating
agg_table$no_rating_percent <- round((agg_table$No_Rating/agg_table$Total_Rating) * 100, 2)
agg_table$yes_rating_percent <- round((agg_table$Yes_Rating/agg_table$Total_Rating) * 100, 2)
# print(agg_table)

#----------
percent_rating_table <- subset(agg_table, select = c("Primary_Genre", "no_rating_percent", "yes_rating_percent"))

least_rating <- percent_rating_table %>% arrange(desc(no_rating_percent))
least_rating <- least_rating[1:10, ]
# print(least_rating)

most_rating <- percent_rating_table %>% arrange(desc(yes_rating_percent))
most_rating <- most_rating[1:10, ]
# print(most_rating)

#-----------
least_rating <- gather(least_rating, key = "Rating", value = "Count", -Primary_Genre)
least_ratings_bar <- ggplot(least_rating, aes(x = Primary_Genre, y = Count, fill = Rating)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Distribution of 'Rating' across 'Genre' among Lowest rating apps", caption = 'Bar chart', x = "Primary Genre", y = "Percentage of ratings", fill = "Rating") +
  scale_fill_manual(values = c("yes_rating_percent" = "chartreuse3", "no_rating_percent" = "firebrick2")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1))
least_ratings_bar

#---------
most_rating <- gather(most_rating, key = "Rating", value = "Count", -Primary_Genre)
most_ratings_bar <- ggplot(most_rating, aes(x = reorder(Primary_Genre, -Count), y = Count, fill = Rating)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Distribution of 'Rating' across 'Genre' among Highest rating apps", caption = 'Bar chart', x = "Primary Genre", y = "Percentage of ratings", fill = "Rating") +
  scale_fill_manual(values = c("yes_rating_percent" = "chartreuse3", "no_rating_percent" = "firebrick2")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1))
most_ratings_bar

```

## Analysis of App size
### Frequency
**Frequency of 'Size_Bytes' for sampled data**
```{r sizebyte_freq_barplot_17}
sampled_data$Size_MB <- sampled_data$Size_Bytes / (1024^2)

sampled_data$Size_Group <- cut(sampled_data$Size_MB, 
                               breaks = seq(0, max(sampled_data$Size_MB), by = 50),
                               labels = seq(25, max(sampled_data$Size_MB) - 25, by = 50))

ggplot(sampled_data, aes(x = Size_Group)) +
  geom_bar(fill = "skyblue", color = "black") +
  labs(title = "Distribution of App Sizes (in MB) - Sampled Data",
       x = "Size (MB)",
       y = "Frequency") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
