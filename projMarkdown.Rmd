---
title: "DATS-6101 Project"
author: "GROUP 7"
date: "2023-10-12"
output: 
  html_document:
    code_folding: hide
    number_sections: false
    toc: yes
    toc_depth: 3
    toc_float: yes
  #pdf_document:
   # toc: yes
    #toc_depth: '3'
---
Our Project uses a Apple Appstore data which has 21 columns. The variables are:

1.App_Id - Unique identifier for the app
2.App_Name - Name of the app
3.AppStore_Url - URL for the app on the Apple App Store
4.Primary_Genre - Main genre of the app
5.Content_Rating- Age rating for the app
6.Size_Bytes- Size of the app in bytes
7.Required_IOS_Version - Minimum iOS version required to run the app
8.Released - Release date of the app
9.Updated - Last update date of the app
10.Version - Current version of the app
11.Price - Price of the app
12.Currency - Currency of the app price
13.Free - Whether the app is free or not
14.DeveloperId - Unique identifier for the app's developer
15.Developer - Name of the app's developer
16.Developer_Url - URL of the developer on the Apple App Store
17.Developer_Website - Official website of the developer
18.Average_User_Rating - Average rating given by users
19.Reviews - Number of reviews
20.Current_Version_Score - Rating for the current version of the app
21.Current_Version_Reviews - Number of reviews for the current version of the app

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ezids)
library(tidyr)
library(lubridate)
library(dplyr)
library(ggplot2)
library(gridExtra)
```

### Reading the AppleStore data into dataframe
```{r read_csv}
appData = read.csv('appleAppData.csv')
```

### Dimenstions of the dataframe
```{r dataset_dimension}
dim(appData)
```

### Datatype of columns
```{r dataset_structure}
str(appData)
```

### Summary of the dataset
```{r dataset_summary}
summary(appData)
```

### First and Last few observations of the dataframe
```{r dataset_rows}
head(appData,2)
tail(appData,2)
```

### Listing the numerical and categorical variables(columns)
```{r numerical_and_categorial_cols}
numerical_cols <- sapply(appData, is.numeric)
numerical_colnames <- names(appData)[numerical_cols]

categorical_colnames <- names(appData)[!numerical_cols]

max_length <- max(length(numerical_colnames), length(categorical_colnames))

numerical_colnames <- c(numerical_colnames, rep(NA, max_length - length(numerical_colnames)))
categorical_colnames <- c(categorical_colnames, rep(NA, max_length - length(categorical_colnames)))

var_df <- data.frame(Numeric = numerical_colnames, Categorical = categorical_colnames)

print(var_df)
```

## Missing values
### Checking all missing values in the dataset
```{r check_missing_values}
na_counts <- sapply(appData, function(col) sum(is.na(col)))

blank_counts <- sapply(appData, function(col) sum(col == "" | col == " "))

result <- data.frame(Column = names(appData), NA_Count = na_counts, Blank_Count = blank_counts)
print(result)
```

### Numerical column NAs
**Barplot showing the number of missing values in columns 'Price' and 'Size_Bytes' columns**
```{r numerical_missing_values_barplot}
# Calculate missing values per column
missing_values_per_column <- colSums(is.na(appData))

# Create a data frame with column names and missing values
missing_data <- data.frame(Column = names(missing_values_per_column),
                           MissingValues = missing_values_per_column)

ggplot(missing_data, aes(x = Column, y = MissingValues)) +
  geom_bar(stat = "identity", fill = "plum3") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Column Names", y = "Number of Missing Values", 
       title = "Number of Missing Values in the dataset")

```

### Categorical column NAs
**Barplot showing the number of missing values in columns 'Developer_Url', 'Developer_Website' and 'Released' columns**
```{r categorical_missing_values_barplot}

# Subset data
missing_data <- data.frame(
  Column = c('Developer_Url', 'Developer_Website', 'Released'),
  Missing_Values = c(blank_developer_url, blank_developer_website, Released)
)

developer_website_data <- subset(missing_data, Column == "Developer_Website")
other_data <- subset(missing_data, Column != "Developer_Website")
custom_colors <- c("Developer_Url" = "indianred4", "Developer_Website" = "indianred3", "Released"="indianred2")

# Plot for Developer_Website
plot1 <- ggplot(developer_website_data, aes(x = Column, y = Missing_Values)) +
  geom_bar(stat = "identity", aes(fill = Column), width = 0.5) +
  scale_fill_manual(values = custom_colors) +
  labs(title = "Missing Values in Developer_Website",
       x = "",
       y = "Number of Missing Values") +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma)

# Plot for Developer_Url and Released
plot2 <- ggplot(other_data, aes(x = Column, y = Missing_Values)) +
  geom_bar(stat = "identity", aes(fill = Column), width = 0.5) +
  scale_fill_manual(values = custom_colors) +
  labs(title = "Missing Values in Developer_Url \nand Released",
       x = "",
       y = "Number of Missing Values") +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma)


# Combine plots
grid.arrange(plot1, plot2, ncol = 2)

```

## Handling missing values
**Removing row with NA value in AppName column**
```{r remove_na_in_appname}
appData <- subset(appData, !is.na(App_Name))
```

**Dropping 'Developer_Website' column as it is not used in the analysis and has missing values for over half the dataset**
```{r drop_dw_col}
appData = subset(appData, select = -c(Developer_Website))
head(appData, 1)
```

**Dropping blanks in 'Released' column**
```{r drop_blanks_in_released_col}
appData <- appData %>% filter(!is.na(Released) & Released != "")
print(tail(appData,4))
```

**Updating NA values in numerical columns 'Price' and 'Size_Bytes' with their respective means**
```{r replace_numerical_na_with_means}
df_p_sb <- subset(appData, select=c("Price", "Size_Bytes"))
head(df_p_sb, 1)
meanvals <- as.list(colMeans(df_p_sb, na.rm = TRUE))
print(meanvals)
df_p_sb <- replace_na(df_p_sb, meanvals)
head(df_p_sb, 1)
appData = subset(appData, select = -c(Price))
appData = subset(appData, select = -c(Size_Bytes))
appData <- cbind(appData, Price = df_p_sb$Price)
appData <- cbind(appData, Size_Bytes = df_p_sb$Size_Bytes)
head(appData, 1)
```

**Final checking for missing values**
```{r final_check_for_missing_vals_barplot}
# Calculate missing values per column
missing_values_per_column_2 <- colSums(is.na(appData))

# Create a data frame with column names and missing values
missing_data_2 <- data.frame(Column = names(missing_values_per_column_2),
                           MissingValues = missing_values_per_column_2)

ggplot(missing_data_2, aes(x = Column, y = MissingValues)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Column Names", y = "Number of Missing Values 2", 
       title = "Number of Missing Values in the dataset")

missing_values_per_column <- colSums(is.na(appData))
print(missing_values_per_column <- colSums(is.na(appData)))
```

**Checking for duplicates**
```{r check_duplicated}
print(sum(duplicated(appData)))
```

## Datetime columns
**Converting 'Released' and 'Updated' columns datatype from object to time format**
```{r dt_cols_format}
appData$Updated <- format(ymd_hms(appData$Updated), "%m-%d-%Y %H:%M:%S")
appData$Released <- format(ymd_hms(appData$Released), "%m-%d-%Y %H:%M:%S")

appData$Released <- as.POSIXct(strptime(appData$Released, "%m-%d-%Y %H:%M:%S"))
appData$Updated <- as.POSIXct(strptime(appData$Updated, "%m-%d-%Y %H:%M:%S"))

print(head(appData,1))
```

## Apps vs Genre
```{r apps_per_genre_barplot_1}
genre_counts <- appData %>%
  group_by(Primary_Genre) %>%
  summarise(App_Count = n())

#genre_counts

ggplot(genre_counts, aes(x = Primary_Genre, y = App_Count)) +
  geom_bar(stat = 'identity', fill = 'blue', alpha = 0.5) +
  labs(title = "Number of Apps per Genre", x = "Genre", y = "Count of Apps") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Revenue vs Genre
```{r revenue_by_genre_barplot_2}
appData$Revenue <- appData$Price * appData$Reviews

revenue_by_genre <- appData %>%
group_by(Primary_Genre) %>%
summarise(Total_Revenue = sum(Revenue))

ggplot(revenue_by_genre, aes(x = reorder(Primary_Genre, -Total_Revenue), y = Total_Revenue)) +
  geom_bar(stat='identity', fill='seagreen4') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Revenue by Genre", x = "Genre", y = "Total Revenue")+
  scale_y_continuous(labels = scales::comma)
```

## Gaming apps
### Frequency over years
```{r gaming_apps_count_over_years_barplot_3}
# Extract release and update years
appData$Release_Year <- year(appData$Released)
appData$Update_Year <- year(appData$Updated)

# Count the number of games per release year
games_per_year <- appData %>% 
  group_by(Release_Year) %>%
  tally()

# Plot the bar graph
ggplot(games_per_year, aes(x = Release_Year, y = n)) +
  geom_bar(stat = 'identity', fill = 'orange4', alpha = 0.5) +
  labs(title = "Number of Games Released Per Year", x = "Release Year", y = "Number of Games") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### Reviews & Rating vs Year
```{r gaming_apps_reviews_and_ratings_over_years_barplot_4}
games_data <- appData[appData$Primary_Genre == 'Games', ]
games_data$Year <- year(as.Date(games_data$Released, format="%d-%m-%Y %H:%M:%S"))

games_by_year <- games_data %>%
  filter(!is.na(Year)) %>%
  group_by(Year) %>%
  summarise(
    Total_Reviews = sum(Reviews, na.rm = TRUE),
    Average_Rating = mean(Average_User_Rating, na.rm = TRUE)
  )

ggplot(games_by_year, aes(x = as.factor(Year))) +
  geom_col(aes(y = Total_Reviews), fill = 'pink4', alpha = 0.5) +
  geom_line(aes(y = Average_Rating*1000000, group=1), color = 'lightcyan4') +  # scaled for visualization
  geom_point(aes(y = Average_Rating*1000000), color = 'lightcyan4') +
  labs(title = "Distribution of Reviews and Rating Over Years", x = "Year", y = "Metrics") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  scale_y_continuous(labels = scales::comma)

```

## Release and Update Frequency over the years
```{r release_and_update_frequency_over_years_linechart_5}

# Calculate the number of releases and updates per year
release_counts <- table(appData$Release_Year)
update_counts <- table(appData$Update_Year)

# Create a data frame for plotting
plot_data <- data.frame(Year = as.numeric(names(release_counts)),
                        Releases = as.numeric(release_counts),
                        Updates = as.numeric(update_counts))

# Plot line chart with solid line and dots for Releases, and solid line with cross marks for Updates
ggplot(plot_data, aes(x = Year)) +
  geom_line(aes(y = Releases, color = "Releases"), linetype = "solid", size = 1) +
  geom_point(aes(y = Releases, color = "Releases"), shape = 16, size = 3) +  # Shape 16 represents dots
  geom_line(aes(y = Updates, color = "Updates"), linetype = "solid", size = 1) +
  geom_point(aes(y = Updates, color = "Updates"), shape = 4, size = 3) +  # Shape 4 represents diamond 
  labs(x = "Year", y = "Count", title = "Release and Update Frequency Over Time") +
  scale_color_manual(values = c("Releases" = "blue", "Updates" = "green")) +
  theme_minimal() + theme(legend.position="top") +
  scale_x_continuous(breaks = seq(2008, 2022, 1)) +
  scale_y_continuous(labels = scales::comma)
```


## Content Rating
#### Frequency
```{r apps_by_contentrating_barplot_6}

# Arrange data by the count of 'Content_Rating' in descending order
ordered_ratings <- appData %>% 
  group_by(Content_Rating) %>% 
  summarise(count = n()) %>%
  arrange(-count) %>%
  .$Content_Rating

# Create the bar plot
ggplot(appData, aes(x = Content_Rating)) +
  geom_bar(aes(fill = Content_Rating), show.legend = FALSE) +
  scale_x_discrete(limits = ordered_ratings) +  # Order bars
  labs(title = "Number of Apps by Content Rating", x = "Content Rating", y = "Number of Apps")
```

### Distribution
```{r apps_by_contentrating_piechart_7}
# Calculate the count of apps by Content Rating
rating_counts <- table(appData$Content_Rating)

# Create a data frame for the pie chart
rating_data <- data.frame(Content_Rating = names(rating_counts), Count = as.numeric(rating_counts))

# Define the desired order for sorting the "Name" column
desired_order <- c("4+", "9+", "12+", "17+", "Not yet rated")

# Sort the data frame based on the "Name" column using the desired order
rating_data <- rating_data %>%
  arrange(factor(Content_Rating, levels = desired_order))

# Calculate percentages
rating_data$Percentage <- (rating_data$Count / sum(rating_data$Count)) * 100
rating_data$Percentage <- round(rating_data$Percentage, 2)

rating_data

custom_colors <- c("#f8766d", "#a3a500", "#00bf7d", "#00b0f6", "slategrey")
# Create a pie chart-like plot
ggplot(rating_data, aes(x = 1, y = Percentage, fill = Content_Rating)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar(theta = "y") +
  labs(title = "Pie Chart: Content Rating", fill = "Content Rating") +
  scale_fill_manual(values = custom_colors) +
  theme_void() +
  theme(legend.position = "right")
```

### Genre vs. Content Rating
```{r genre_vs_contentrating_spbarplot_8}
pg_cr <- subset(appData, select = c('Primary_Genre', 'Content_Rating'))
pg_cr_agg <- pg_cr %>%  
             group_by(Primary_Genre, Content_Rating) %>% 
            summarise(total_count = n(), .groups = 'drop') %>% 
            pivot_wider(names_from = Content_Rating, values_from = total_count, values_fill = 0)
print(pg_cr_agg)
col_order <- c("Primary_Genre", "4+", "9+", "12+", "17+", "Not yet rated")
pg_cr_agg <- pg_cr_agg[, col_order]
pg_cr_agg


pgcr_data_long <- pg_cr_agg %>%
  gather(Rating, Count, -Primary_Genre)

# Calculate percentages within each Primary_Genre
pgcr_data_longg <- pgcr_data_long %>%
  group_by(Primary_Genre) %>%
  mutate(Percentage = (Count / sum(Count)) * 100)

# Create a stacked percentage bar chart with Primary_Genre on the x-axis
ggplot(pgcr_data_longg, aes(x = Primary_Genre, y = Percentage, fill = Rating)) +
  geom_bar(stat = "identity") +
  labs(title = "Percentage Distribution of 'Content Rating' across 'Genre'", caption = 'Stacked Percentage Bar Chart', x = "Primary Genre", y = "Content Rating %") +
  scale_fill_manual(values = c("4+" = "gold", "9+" = "darkorange", "12+" = "brown2", "17+" = "firebrick3", "Not yet rated" = "red4")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(labels = scales::percent_format(scale = 1))
```

### Pearson's Chi-squared test
**Pearson's Chi-squared test between Genre and Content_Rating**
```{r chisq_test_genre_vs_contentrating}
# Create a contingency table
contingency_table <- table(appData$Primary_Genre, appData$Content_Rating)

# Perform the chi-squared test
chi_square_result <- chisq.test(contingency_table)

# View the test result
print(chi_square_result)
```
