---
title: "DATS-6101"
author: "GROUP 7"
date: "2023-10-12"
output: 
  html_document:
    code_folding: hide
    number_sections: false
    toc: yes
    toc_depth: 3
    toc_float: yes
  #pdf_document:
   # toc: yes
    #toc_depth: '3'
---
Our Project uses a Apple Appstore data which has 21 columns.

The variables are:


Our Project uses a Apple Appstore data which has 21 columns.

The variables are:
1.App_Id - Unique identifier for the app
2.App_Name - Name of the app
3.AppStore_Url - URL for the app on the Apple App Store
4.Primary_Genre - Main genre of the app
5.Content_Rating- Age rating for the app
6.Size_Bytes- Size of the app in bytes
7.Required_IOS_Version - Minimum iOS version required to run the app
8.Released - Release date of the app
9.Updated - Last update date of the app
10.Version - Current version of the app
11.Price - Price of the app
12.Currency - Currency of the app price
13.Free - Whether the app is free or not
14.DeveloperId - Unique identifier for the app's developer
15.Developer - Name of the app's developer
16.Developer_Url - URL of the developer on the Apple App Store
17.Developer_Website - Official website of the developer
18.Average_User_Rating - Average rating given by users
19.Reviews - Number of reviews
20.Current_Version_Score - Rating for the current version of the app
21.Current_Version_Reviews - Number of reviews for the current version of the app

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ezids)
library(tidyr)
library(lubridate)
library(dplyr)
library(ggplot2)
```

### Reading the Apple App Data CSV into the data frame

```{r}
appData = read.csv('appleAppData.csv')
```

### Dimenstions of the data frame

```{r}
dim(appData)
```
### Datatype of columns

```{r}
str(appData)
```

### Summary of the dataset

```{r}
summary(appData)
```
### First five and Last five observations of the data frame

```{r}
head(appData,2)
tail(appData,2)
```
### Listing the numerical and categorical variables(columns)

```{r}
numerical_cols <- sapply(appData, is.numeric)
numerical_colnames <- names(appData)[numerical_cols]

categorical_colnames <- names(appData)[!numerical_cols]

max_length <- max(length(numerical_colnames), length(categorical_colnames))

numerical_colnames <- c(numerical_colnames, rep(NA, max_length - length(numerical_colnames)))
categorical_colnames <- c(categorical_colnames, rep(NA, max_length - length(categorical_colnames)))

var_df <- data.frame(Numeric = numerical_colnames, Categorical = categorical_colnames)

print(var_df)
```

```{r}
missing_values <- sum(is.na(appData))
cat("Total missing values in the dataset:", missing_values, "\n")
missing_values_per_column <- colSums(is.na(appData))
cat("Missing values per column:\n")
print(missing_values_per_column)
```

### Checking all missing values in the dataset
```{r}
na_counts <- sapply(appData, function(col) sum(is.na(col)))

blank_counts <- sapply(appData, function(col) sum(col == "" | col == " "))

result <- data.frame(Column = names(appData), NA_Count = na_counts, Blank_Count = blank_counts)
print(result)
```

```{r}
# Total missing values in the dataset
missing_values <- sum(is.na(appData))
cat("Total missing values in the dataset:", missing_values, "\n")

# Missing values per column
missing_values_per_column <- colSums(is.na(appData))
cat("Missing values per column:\n")
print(missing_values_per_column)

# Number of missing values in 'Developer_Url' column
blank_developer_url <- sum(is.na(appData$Developer_Url) | appData$Developer_Url == "")
cat("Number of missing values in 'Developer_Url' column:", blank_developer_url, "\n")

# Number of missing values in 'Developer_Website' column
blank_developer_website <- sum(is.na(appData$Developer_Website) | appData$Developer_Website == "")
cat("Number of missing values in 'Developer_Website' column:", blank_developer_website, "\n")

# Number of missing values in 'Released' column
Released_column <- sum(is.na(appData$Released) | appData$Released == "")
cat("Number of missing values in 'Released' column:", Released_column, "\n")

```

### Barplot showing the number of missing values
```{r}
# Calculate missing values per column
missing_values_per_column <- colSums(is.na(appData))

# Create a data frame with column names and missing values
missing_data <- data.frame(Column = names(missing_values_per_column),
                           MissingValues = missing_values_per_column)

ggplot(missing_data, aes(x = Column, y = MissingValues)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Column Names", y = "Number of Missing Values", 
       title = "Number of Missing Values in the dataset")

```


```{r}
# Calculate the number of missing values in 'Developer_Url' ,'Developer_Website' and Released columns
blank_developer_url <- sum(is.na(appData$Developer_Url) | appData$Developer_Url == "")
blank_developer_website <- sum(is.na(appData$Developer_Website) | appData$Developer_Website == "")
Released <- sum(is.na(appData$Released) | appData$Released == "")

# Create a data frame for plotting
missing_data <- data.frame(
  Column = c('Developer_Url', 'Developer_Website', 'Released'),
  Missing_Values = c(blank_developer_url, blank_developer_website, Released)
)


# Create a bar plot
ggplot(missing_data, aes(x = Column, y = Missing_Values, fill = Column)) +
  geom_bar(stat = "identity") +
  labs(title = "Number of Missing Values in Columns",
       x = "Column Names",
       y = "Number of Missing Values") +
  theme_minimal()

```
### Removing the NA value in the column AppNAme

```{r}
appData <- subset(appData, !is.na(App_Name))
```

### Dropping Developer_Website column

```{r}
# Dropping Developer_Website column
appData = subset(appData, select = -c(Developer_Website))
head(appData, 1)
```

# Dropping blanks in "Released" column:

```{r}
# Drop rows where 'Released' column is blank
appData <- appData %>% filter(!is.na(Released) & Released != "")

# Print the updated data frame
print(tail(appData,4))
```

### Updating Price and Size_Bytes columns' NA values with mean

```{r}
df_p_sb <- subset(appData, select=c("Price", "Size_Bytes"))
head(df_p_sb, 1)
meanvals <- as.list(colMeans(df_p_sb, na.rm = TRUE))
print(meanvals)
df_p_sb <- replace_na(df_p_sb, meanvals)
head(df_p_sb, 1)
appData = subset(appData, select = -c(Price))
appData = subset(appData, select = -c(Size_Bytes))
appData <- cbind(appData, Price = df_p_sb$Price)
appData <- cbind(appData, Size_Bytes = df_p_sb$Size_Bytes)
head(appData, 1)
```
```{r}
# write.csv(appData, "C:\\Users\\Krishnasurya\\Documents\\exported\\appData.csv", row.names=TRUE)
# Calculate missing values per column
missing_values_per_column_2 <- colSums(is.na(appData))

# Create a data frame with column names and missing values
missing_data_2 <- data.frame(Column = names(missing_values_per_column_2),
                           MissingValues = missing_values_per_column_2)

ggplot(missing_data_2, aes(x = Column, y = MissingValues)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Column Names", y = "Number of Missing Values 2", 
       title = "Number of Missing Values in the dataset")

missing_values_per_column <- colSums(is.na(appData))
print(missing_values_per_column <- colSums(is.na(appData)))

# appData = appData[appData$App_Name != 'nan', ]

# # Calculate missing values per column
# missing_values_per_column_3 <- colSums(is.na(appData))
# 
# # Create a data frame with column names and missing values
# missing_data_3 <- data.frame(Column = names(missing_values_per_column_3),
#                            MissingValues = missing_values_per_column_3)
# 
# ggplot(missing_data_3, aes(x = Column, y = MissingValues)) +
#   geom_bar(stat = "identity", fill = "skyblue") +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
#   labs(x = "Column Names", y = "Number of Missing Values 3",
#        title = "Number of Missing Values in the dataset")
```
### Number of duplicates in the dataset

```{r}
print(sum(duplicated(appData)))
```

###Converting object format to time format

```{r}
appData$Updated <- format(ymd_hms(appData$Updated), "%m-%d-%Y %H:%M:%S")
appData$Released <- format(ymd_hms(appData$Released), "%m-%d-%Y %H:%M:%S")

print(head(appData,1))
```

###Repesenatation of Revenue generated by Genre
```{r}
appData$Revenue <- appData$Price * appData$Reviews

library(dplyr)
library(gridExtra)
revenue_by_genre <- appData %>%
group_by(Primary_Genre) %>%
summarise(Total_Revenue = sum(Revenue))


library(ggplot2)
ggplot(revenue_by_genre, aes(x = reorder(Primary_Genre, -Total_Revenue), y = Total_Revenue)) +
  geom_bar(stat='identity', fill='skyblue') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Revenue by Genre", x = "Genre", y = "Total Revenue")

```
###Performance of Game Genre Over Years
```{r}
games_data <- appData[appData$Primary_Genre == 'Games', ]
games_data$Year <- year(as.Date(games_data$Released, format="%d-%m-%Y %H:%M:%S"))

games_by_year <- games_data %>%
  filter(!is.na(Year)) %>%
  group_by(Year) %>%
  summarise(
    Total_Reviews = sum(Reviews, na.rm = TRUE),
    Average_Rating = mean(Average_User_Rating, na.rm = TRUE)
  )

ggplot(games_by_year, aes(x = as.factor(Year))) +
  geom_col(aes(y = Total_Reviews), fill = 'black', alpha = 0.5) +
  geom_line(aes(y = Average_Rating*1000, group=1), color = 'red') +  # scaled for visualization
  geom_point(aes(y = Average_Rating*1000), color = 'red') +
  labs(title = "Game Genre's Performance Over Years", x = "Year", y = "Metrics") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

###Number of Apps per Genre
```{r}
genre_counts <- appData %>%
  group_by(Primary_Genre) %>%
  summarise(App_Count = n())

#genre_counts

ggplot(genre_counts, aes(x = Primary_Genre, y = App_Count)) +
  geom_bar(stat = 'identity', fill = 'blue', alpha = 0.5) +
  labs(title = "Number of Apps per Genre", x = "Genre", y = "Count of Apps") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### The function computes the correlation coefficient for pairs of numeric columns
```{r}
cor(appData[, sapply(appData, is.numeric)])
```
### Pearson's Chi-squared test for Content_Rating vs. Primary_Genre
```{r}
chisq.test(appData$Content_Rating, appData$Primary_Genre)
```
### ANOVA test for Primary_Genre vs. Average_User_Rating
```{r}
aov_result <- aov(Average_User_Rating ~ Primary_Genre, data=appData)
summary(aov_result)
```
### Sample 1000 rows from our dataset :
```{r}
sampled_data <- appData %>%
  sample_n(1000)
# Created custom bins for Average_User_Rating (e.g., every 0.5 units)
sampled_data$Rating_Group <- cut(sampled_data$Average_User_Rating, 
                                 breaks = seq(0, 5, by = 0.5),
                                 labels = seq(0.25, 4.75, by = 0.5))
# Load the required libraries
library(lubridate)
library(dplyr)
library(ggplot2)
```
# Assuming "Released" is in "MM/DD/YYYY" format
```{r}
# Display a sample of the "Released" column
head(appData$Released, 10)
# Convert "Released" to a standard date format
appData$Released <- as.Date(appData$Released, format = "%m/%d/%Y")
# Display a sample of the "Released" column after conversion
head(appData$Released, 10)
```
### Bar plot for grouped Average_User_Rating :
```{r}
ggplot(sampled_data, aes(x = Rating_Group)) +
  geom_bar(fill = "skyblue", color = "black") +
  labs(title = "Distribution of Average User Ratings (Sampled Data)",
       x = "Average User Rating",
       y = "Frequency") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


sampled_data$Size_MB <- sampled_data$Size_Bytes / (1024^2)

sampled_data$Size_Group <- cut(sampled_data$Size_MB, 
                               breaks = seq(0, max(sampled_data$Size_MB), by = 50),
                               labels = seq(25, max(sampled_data$Size_MB) - 25, by = 50))
```
### Bar plot for grouped Size_MB :
```{r}
ggplot(sampled_data, aes(x = Size_Group)) +
  geom_bar(fill = "skyblue", color = "black") +
  labs(title = "Distribution of App Sizes (in MB) - Sampled Data",
       x = "Size (MB)",
       y = "Frequency") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
# Create a bar plot for Price
```{r}
ggplot(sampled_data, aes(x = factor(Price))) +
  geom_bar(fill = "skyblue", color = "black") +
  labs(title = "Distribution of App Prices (Sampled Data)",
       x = "Price",
       y = "Frequency") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)
)
```
### Aggregate data to get average price for each year
```{r}
# Convert 'Released' and 'Updated' columns to datetime objects
appData$Released <- as.POSIXct(strptime(appData$Released, "%m-%d-%Y %H:%M:%S"))
appData$Updated <- as.POSIXct(strptime(appData$Updated, "%m-%d-%Y %H:%M:%S"))

# Extract release and update years
appData$Release_Year <- year(appData$Released)
appData$Update_Year <- year(appData$Updated)

# App price over a period of time
ggplot(appData, aes(x = Release_Year, y = Price, color = Primary_Genre)) +
  geom_point(data = na.omit(appData), alpha = 0.5) +
  labs(title = "App Price Trends Over Time", x = "Year of Release", y = "App Price (USD)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_color_discrete(name = "Primary Genre") +
  scale_y_continuous(labels = scales::comma)
```
### Aggregate data to get average size for each year :
```{r}
# App size (in MB) over time
appData$Size_MB <- appData$Size_Bytes / (1024^2)
# App size (in MB) over time
appData$Size_MB <- appData$Size_Bytes / (1024^2)  # Create the Size_MB variable
ggplot(appData, aes(x = Release_Year, y = Size_MB, color = Primary_Genre)) +
  geom_point(data = na.omit(appData), alpha = 0.5) +
  labs(title = "App Size Trends Over Time", x = "Year of Release", y = "App Size (MB)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_color_discrete(name = "Primary Genre") +
  scale_y_continuous(labels = scales::comma)
```
### Aggregate data to get average rating for each year :
```{r}
# App average user ratings over time
ggplot(appData, aes(x = Release_Year, y = Average_User_Rating, color = Primary_Genre)) +
  geom_point(data = na.omit(appData), alpha = 0.5) +
  labs(title = "Average User Ratings Trends Over Time", x = "Year of Release", y = "Average User Rating") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_color_discrete(name = "Primary Genre") +
  scale_y_continuous(labels = scales::comma)
```

## Plot showing Release and Update Frequency Over Time
```{r}

# Convert 'Released' and 'Updated' columns to datetime objects
appData$Released <- as.POSIXct(strptime(appData$Released, "%m-%d-%Y %H:%M:%S"))
appData$Updated <- as.POSIXct(strptime(appData$Updated, "%m-%d-%Y %H:%M:%S"))

# Extract release and update years
appData$Release_Year <- year(appData$Released)
appData$Update_Year <- year(appData$Updated)

# Calculate the number of releases and updates per year
release_counts <- table(appData$Release_Year)
update_counts <- table(appData$Update_Year)

# Create a data frame for plotting
plot_data <- data.frame(Year = as.numeric(names(release_counts)),
                        Releases = as.numeric(release_counts),
                        Updates = as.numeric(update_counts))

# Plot line chart with solid line and dots for Releases, and solid line with cross marks for Updates
ggplot(plot_data, aes(x = Year)) +
  geom_line(aes(y = Releases, color = "Releases"), linetype = "solid", size = 1) +
  geom_point(aes(y = Releases, color = "Releases"), shape = 16, size = 3) +  # Shape 16 represents dots
  geom_line(aes(y = Updates, color = "Updates"), linetype = "solid", size = 1) +
  geom_point(aes(y = Updates, color = "Updates"), shape = 4, size = 3) +  # Shape 4 represents diamond 
  labs(x = "Year", y = "Count", title = "Release and Update Frequency Over Time") +
  scale_color_manual(values = c("Releases" = "blue", "Updates" = "green")) +
  theme_minimal() + theme(legend.position="top") +
  scale_x_continuous(breaks = seq(2008, 2022, 1)) +
  scale_y_continuous(labels = scales::comma)
```
### Bar graph No. of Apps Vs. Content Rating
```{r}
#library(dplyr)
# Arrange data by the count of 'Content_Rating' in descending order
ordered_ratings <- appData %>% 
  group_by(Content_Rating) %>% 
  summarise(count = n()) %>%
  arrange(-count) %>%
  .$Content_Rating

# Create the bar plot
ggplot(appData, aes(x = Content_Rating)) +
  geom_bar(aes(fill = Content_Rating), show.legend = FALSE) +
  scale_x_discrete(limits = ordered_ratings) +  # Order bars
  labs(title = "Number of Apps by Content Rating", x = "Content Rating", y = "Number of Apps")
```
### Pie cart for No. of Apps per Content Rating
```{r}
# Calculate the count of apps by Content Rating
rating_counts <- table(appData$Content_Rating)

# Create a data frame for the pie chart
rating_data <- data.frame(Content_Rating = names(rating_counts), Count = as.numeric(rating_counts))

# Create a pie chart for Content Rating
ggplot(rating_data, aes(x = "", y = Count, fill = Content_Rating)) +
  geom_bar(stat = "identity") +
    coord_polar("y") +
      ggtitle('Distribution of Apps by Content Rating') +
        theme_void() +
          theme(legend.position = "bottom")  # Optional: move the legend to the bottom
```
